Game Construction
---------------------------

The 'GameBoard' class is given some information on what divs to use for
the game itself, and the background. It's also told how many rows and
columns are to be used for the game (if the CSS is updated and this
number changed, you could have potentially far larger game boards.)

No images are used anywhere in the game, everything is generated by 
JS/CSS.

The GameBoard instance creates all the related UI elements, including
the spheres and then begins the timer. Each sphere has an on-click event
to detect when the user is interacting 
(See:
	- gameboard.js: GameBoard.method('start', function () {...});
)

When a sphere is clicked, the game seeks out all adjacent nodes of the
same color and highlights them. If a highlighted sphere is clicked, the
highlighted nodes are then removed.
(See:
	- gameboard.js: GameBoard_event_onClickSphere...
	- gameboard.js: GameBoard__handleExisting...
	- sphere.js: Sphere.method('moveto', function (x, y) {...});
	- gameboard.js: GameBoard__selectAdjacent...
)

The score is calculated in the scorebox depending on how many nodes were
highlighted on a click. The number of nodes highlighted is sent to the
scorebox instance to update the selected score. To update the running
score, the number of nodes removed is sent to the scorebox instance. The
scorebox also manages the running of the timer.
(See:
	- gameboard.js: GameBoard__selectAdjacent...
		-> $board.scorebox.updateselection(adj.length);
	- gameboard.js: GameBoard__handleExisting...
		-> $board.scorebox.updateselection(0);
		-> $board.scorebox.addscore(nPoints);
	- scorebox.js
)

At every move where items are removed from the board by the user, a 
check is run across the game board to see if any two nodes of the same
color are left next to each other. If there are, we let the game
continue. Otherwise, the game ends. This also implicitly takes care of
the case where every node is removed from the board.
(See:
	- gameboard.js: GameBoard.method('checkwin', function () {...});
	- gameboard.js: GameBoard.method('finishround', function () {...});
)

Once the game ends, we present the user with several options. They may
submit their score with their name, start a new game, or simply close
the options screen. The options screen is presented as a modal dialog
box.
(See:
	- gameboard.js: GameBoard.method('finishround', function () {...});
		-> var m = new Modal(...);
	- modal.js
	- index.css: .modal and all it's child elements
		- specifically, .modal:target
)

If the user decides to submit (or view) their high scores, the scorebox
fetches the page generated by topScore.pl using a non-asynchronous ajax
call. Once the call has been completed successfully, a regex is applied
to extract the username/pointscore pairs so it can be displayed within
a custom table inside the game instead (in its own modal dialog). If the
user submitted a score, this is also sent with the ajax request.
(See:
	- scorebox.js: Scorebox.method('gethighscores', function (username, score) {...});
	- scorebox.js: Scorebox__displayTopScores...
)

Finally, the user may reset the game at any time by clicking on new
game. There are also other small visual features available by clicking
on the two small boxes at the top right of the screen. The top switches
between "circles" to "boxes" view. The one below switches between the
assignment-style box-highlighting of all selected nodes to my own
highlighting style. I recommend the latter in each case :)
(See:
	- gameboard.js: (constructor)
	- gameboard.js: GameBoard.method('reset', function () {...});
)